<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Ruby Modules</title>
    <meta name="viewport" content="width=device-width">

    <link href='http://fonts.googleapis.com/css?family=Ubuntu:400,500|Raleway:400' rel='stylesheet' type='text/css'>

    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/blog/css/syntax.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/main.css">
  </head>
  <body>
    <div class="container">
      <div class="site">
        <div class="header">
          <h1 class="title"><a href="/blog/">Nitish's Blog</a></h1>
        </div>

        <div class="post-header">
  <div>Ruby Modules</div>
  <p class="meta">09 Feb 2014</p>
</div>

<div class="post">
  <p>Modules are great for code organization. They are typically used for organizing related code together and mixing them in other classes and modules when required. All modules are instances of <strong>Module</strong> class. Modules are similar to classes. In fact, class <code>Module</code> is superclass of class <code>Class</code>. Unlike classes, modules cannot be instantiated. They don&#8217;t support inheritance either. A module is defined using <strong>module</strong> keyword.</p>
<div class='highlight'><pre><code class='ruby'><span class='k'>module</span> <span class='nn'>A</span>
  <span class='c1'># module body</span>
<span class='k'>end</span>
</code></pre></div>
<p>Modules consist of methods, constants, classes and other modules. Methods in a module can be of two types: <strong>module methods</strong> or <strong>instance methods</strong>. Module methods are defined by using self keyword. They are basically singleton methods on module object and can be accessed directly using module name. Module&#8217;s instance methods can be used by other modules and classes by including or extending module. The <strong>include</strong> method makes all instance methods of the included module available as instance methods whereas the <strong>extend</strong> method makes all instance methods available as singleton methods of the class or module from which it is called.</p>
<div class='highlight'><pre><code class='ruby'><span class='o'>&gt;&gt;</span> <span class='k'>module</span> <span class='nn'>A</span>
<span class='o'>&gt;&gt;</span>   <span class='c1'># instance method</span>
<span class='o'>&gt;&gt;</span>   <span class='k'>def</span> <span class='nf'>method1</span>
<span class='o'>&gt;&gt;</span>     <span class='nb'>puts</span> <span class='s2'>&quot;In method 1&quot;</span>
<span class='o'>&gt;&gt;</span>   <span class='k'>end</span>
<span class='o'>&gt;&gt;</span>
<span class='o'>&gt;&gt;</span>   <span class='c1'># Module method</span>
<span class='o'>&gt;&gt;</span>   <span class='k'>def</span> <span class='nc'>self</span><span class='o'>.</span><span class='nf'>method2</span>
<span class='o'>&gt;&gt;</span>     <span class='nb'>puts</span> <span class='s2'>&quot;In method 2&quot;</span>
<span class='o'>&gt;&gt;</span>   <span class='k'>end</span>
<span class='o'>&gt;&gt;</span> <span class='k'>end</span>
<span class='o'>&gt;&gt;</span>
<span class='sc'>?&gt;</span> <span class='k'>module</span> <span class='nn'>B</span>
<span class='o'>&gt;&gt;</span>   <span class='kp'>include</span> <span class='n'>A</span>
<span class='o'>&gt;&gt;</span> <span class='k'>end</span>
<span class='o'>&gt;&gt;</span>
<span class='sc'>?&gt;</span> <span class='k'>class</span> <span class='nc'>C</span>
<span class='o'>&gt;&gt;</span>   <span class='kp'>include</span> <span class='n'>B</span>
<span class='o'>&gt;&gt;</span> <span class='k'>end</span>
<span class='o'>&gt;&gt;</span>
<span class='sc'>?&gt;</span> <span class='k'>class</span> <span class='nc'>D</span>
<span class='o'>&gt;&gt;</span>   <span class='kp'>extend</span> <span class='n'>B</span>
<span class='o'>&gt;&gt;</span> <span class='k'>end</span>

<span class='c1'># Calling module method</span>
<span class='o'>&gt;&gt;</span> <span class='n'>A</span><span class='o'>.</span><span class='n'>method2</span>
<span class='no'>In</span> <span class='nb'>method</span> <span class='mi'>2</span>

<span class='c1'># Calling included method</span>
<span class='o'>&gt;&gt;</span> <span class='n'>C</span><span class='o'>.</span><span class='n'>new</span><span class='o'>.</span><span class='n'>method1</span>
<span class='no'>In</span> <span class='nb'>method</span> <span class='mi'>1</span>

<span class='c1'># Calling extended method</span>
<span class='o'>&gt;&gt;</span> <span class='n'>D</span><span class='o'>.</span><span class='n'>method1</span>
<span class='no'>In</span> <span class='nb'>method</span> <span class='mi'>1</span>
</code></pre></div>
<p>From the example above, you can see that a method need not be defined in the class of the object on which it is called. It could be defined in any of the ancestor classes or in modules included by those classes. When you call a method on an object, it looks for that method at the following places:</p>

<ol>
<li>It&#8217;s class</li>

<li>Included modules</li>

<li>Parent class</li>

<li>Modules included by parent class</li>
</ol>

<p>and so on&#8230; all the way to the <code>BasicObject</code> class.</p>

<p>When two or more methods have the same name, the one defined later gets called. If the same method is defined in two or more included modules, the one in the most recently included module gets called. Including a module more than once has no effect.</p>

<p>If method is not found, the interpreter sends a special message <strong>method_missing</strong> to the receiver along with the symbol of non-existent method and array of parameters passed to the method.</p>

<p>It is possible to call an overridden method using <strong>super</strong>. You can use super keyword inside the body of a method definition to pass the method call up the lookup chain. When called without arguments e.g. <code>super</code>, it passes all the parameter received by the method from which it&#8217;s called. You can also explicitly pass 0 or more parameters e.g. <code>super()</code> or <code>super(a, b)</code>.</p>

<p>Ruby allows you to nest classes inside modules or modules inside classes. Further, you can encapsulate code in both modules and classes in a similar way. There is no particular rule to consider while picking classes or modules for your program&#8217;s architecture. You have to consider the limits of both the constructs and use them in a sensible way.</p>
</div>

<hr id="comments-seperator">


<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'nitishsp';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>No JS, No comments!</noscript>


      </div>
    </div> <!-- /container -->
  </body>
</html>
